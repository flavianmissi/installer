package manifests

import (
	"fmt"
	"path/filepath"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/yaml"

	imageregistryv1 "github.com/openshift/api/imageregistry/v1"
	operatorv1 "github.com/openshift/api/operator/v1"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
	"github.com/openshift/installer/pkg/types"
	"github.com/openshift/installer/pkg/types/azure"
)

var clusterImageRegistryConfigFile = filepath.Join(manifestDir, "cluster-image-registry-02-config.yml")

// ImageRegistry generates the cluster-image-registry-*.yml files.
type ImageRegistry struct {
	FileList []*asset.File
}

var _ asset.WritableAsset = (*ImageRegistry)(nil)

// Name returns a human friendly name for the asset.
func (*ImageRegistry) Name() string {
	return "Image Registry Config"
}

// Dependencies returns all of the dependencies directly needed to generate
// the asset.
func (*ImageRegistry) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
	}
}

// Generate generates the internal image registry cluster config.
//
// A cluster image registry config is only created for Azure when the cluster
// is using an internal publishing strategy.
func (ir *ImageRegistry) Generate(dependencies asset.Parents) error {
	installConfig := &installconfig.InstallConfig{}
	dependencies.Get(installConfig)

	config := installConfig.Config

	if config.Platform.Name() != azure.Name || config.Publish != types.InternalPublishingStrategy {
		return nil
	}

	clusterConfig, err := ir.generateClusterConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create cluster config for internal image registry: %w", err)
	}
	ir.FileList = []*asset.File{{
		Filename: clusterImageRegistryConfigFile,
		Data:     clusterConfig,
	}}

	return nil
}

func (ir *ImageRegistry) generateClusterConfig(config *types.InstallConfig) ([]byte, error) {
	obj := &imageregistryv1.Config{
		TypeMeta: metav1.TypeMeta{
			APIVersion: imageregistryv1.GroupVersion.String(),
			Kind:       "Config",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: "cluster",
			// not namespaced

			// the registry operator will not generate its own default config
			// unless we explicitly tell it that this config was generated by us.
			// note that only the storage part of this is used by the registry
			// operator, and only for Azure.
			Annotations: map[string]string{"installer-bootstrapped": ""},
		},
		Spec: imageregistryv1.ImageRegistrySpec{
			OperatorSpec: operatorv1.OperatorSpec{
				ManagementState: operatorv1.Managed, // needed to pass validation
			},
			Storage: imageregistryv1.ImageRegistryConfigStorage{
				Azure: &imageregistryv1.ImageRegistryConfigStorageAzure{
					NetworkAccess: &imageregistryv1.AzureNetworkAccess{
						Type: imageregistryv1.AzureNetworkAccessTypeInternal,
					},
				},
			},
		},
	}

	// if we know the network resource group, vnet or subnet names in advance,
	// pass it on to the registry operator.

	if networkResourceGroup := config.Azure.NetworkResourceGroupName; networkResourceGroup != "" {
		if obj.Spec.Storage.Azure.NetworkAccess.Internal == nil {
			obj.Spec.Storage.Azure.NetworkAccess.Internal = &imageregistryv1.AzureNetworkAccessInternal{}
		}
		obj.Spec.Storage.Azure.NetworkAccess.Internal.NetworkResourceGroupName = networkResourceGroup
	}

	if vnet := config.Azure.VirtualNetwork; vnet != "" {
		if obj.Spec.Storage.Azure.NetworkAccess.Internal == nil {
			obj.Spec.Storage.Azure.NetworkAccess.Internal = &imageregistryv1.AzureNetworkAccessInternal{}
		}
		obj.Spec.Storage.Azure.NetworkAccess.Internal.VNetName = vnet
	}

	if subnet := config.Azure.ComputeSubnet; subnet != "" {
		if obj.Spec.Storage.Azure.NetworkAccess.Internal == nil {
			obj.Spec.Storage.Azure.NetworkAccess.Internal = &imageregistryv1.AzureNetworkAccessInternal{}
		}
		obj.Spec.Storage.Azure.NetworkAccess.Internal.SubnetName = subnet
	}

	return yaml.Marshal(obj)
}

// Files returns the files generated by the asset.
func (ir *ImageRegistry) Files() []*asset.File {
	return ir.FileList
}

// Load returns false since this asset is not written to disk by the installer.
func (ir *ImageRegistry) Load(asset.FileFetcher) (bool, error) {
	return false, nil
}
